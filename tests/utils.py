from http import HTTPStatus
from unittest.mock import patch

from flask import Flask, request, jsonify, Flask as App, session

from flask_azure_oauth import FlaskAzureOauth
from flask_azure_oauth.tokens import AzureTokenValidator
from flask_azure_oauth.mocks.tokens import TestJwt as _TestJwt
from flask_azure_oauth.mocks.keys import TestJwk as _TestJwk


class TestJwk(_TestJwk):
    """
    Class to create JSON Web Keys (JWKs) for more extreme testing purposes

    This class builds upon the main TestJwk class, intended for using this extension in other applications, by adding
    methods for testing this extension itself, such as generating JWKs that are intentionally broken.

    By default a unique Key ID is generated for each key, but this can be specified when this should equal another key
    in order to fail token signature validation during tests.
    """

    def __init__(self, *, kid: str = None, null_jwks: bool = False):
        """
        :type kid: str
        :param kid: Key ID
        :type null_jwks: bool
        :param null_jwks: whether an empty JWKS should be returned
        """
        super().__init__()

        if kid is not None:
            self.key_id = kid
        self.null_jwks = null_jwks

    def jwks(self) -> dict:
        """
        Returns the JWK as a Python dictionary, as part of a JSON Web Key Set (JWKS), suitable for encoding with JSON
        for exchange

        Extends the regular TestJwk class to support returning an empty key set for testing

        :rtype dict
        :return: JWK as a JWK Set
        """
        if self.null_jwks:
            return {"keys": []}

        return {"keys": [self.dumps()]}


class TestJwt(_TestJwt):
    """
    Class to create JSON Web Tokens (JWTs) for more extreme testing purposes

    This class builds upon the main TestJwt class, intended for using this extension in other applications, by adding
    methods for testing this extension itself, such as generating JWTs that intentionally omit required elements.

    Supports generating tokens with a configurable header, payload, including scopes, and signing key. Defaults are
    provided for the header and payload to create tokens compatible with a JSON Web Key (signing keys) generated by the
    TestJwk class.
    """

    def __init__(
        self,
        *,
        app: App,
        header: dict = None,
        payload: dict = None,
        roles: list = None,
        scps: list = None,
        signing_key: TestJwk = None,
    ):
        """
        :type app: App
        :type app: Flask application
        :type header: dict
        :param header: header fields to include in token, overrides default values if given
        :type payload: dict
        :param payload: payload claims to include in token, overrides default values if given
        :type roles: list
        :param roles: Optional scopes to include in the token (as a 'roles' claim) for testing authorisation
        :type scps: list
        :param scps: Optional scopes to include in the token (as a 'scp' claim) for testing authorisation
        :type signing_key: TestJwk
        :param signing_key: Optional TestJwk instance for setting the token Key ID, signing algorithm and private key
        for signing
        """
        super().__init__(app=app, roles=roles, scps=scps)

        if signing_key is not None:
            self.signing_key = signing_key
        if header is not None:
            self.header = header
        if payload is not None:
            self.payload = payload


class TestFlaskAzureOauth(FlaskAzureOauth):
    """
    Test specific version of TestFlaskAzureOauth class to allow normally invalid JSON Web Key Set configurations
    """

    def use_null_jwks(self) -> None:
        """
        Replaces the token validator with a version where the JSON Web Key Set is empty
        """
        self.deregister_token_validator(self.validator)

        token_validator = AzureTokenValidator(
            azure_tenancy_id=self.azure_tenancy_id,
            azure_application_id=self.azure_application_id,
            azure_client_application_ids=self.azure_client_application_ids,
            azure_jwks=TestJwk(null_jwks=True).jwks(),
        )
        self.register_token_validator(token_validator)

    def use_broken_jwks(self) -> None:
        """
        Replaces the token validator with a version where the JSON Web Key Set contains a broken JWK (missing key type)
        """
        self.deregister_token_validator(self.validator)

        broken_jwks = self.jwks
        del broken_jwks["keys"][0]["kty"]

        token_validator = AzureTokenValidator(
            azure_tenancy_id=self.azure_tenancy_id,
            azure_application_id=self.azure_application_id,
            azure_client_application_ids=self.azure_client_application_ids,
            azure_jwks=broken_jwks,
        )
        self.register_token_validator(token_validator)

    def use_replaced_jwks(self) -> None:
        """
        Replaces the token validator with a version where the JSON Web Key Set has been replaced but uses the same KID
        """
        self.deregister_token_validator(self.validator)

        previous_kid = self.jwks["keys"][0]["kid"]

        token_validator = AzureTokenValidator(
            azure_tenancy_id=self.azure_tenancy_id,
            azure_application_id=self.azure_application_id,
            azure_client_application_ids=self.azure_client_application_ids,
            azure_jwks=TestJwk(kid=previous_kid).jwks(),
        )
        self.register_token_validator(token_validator)

    def use_restored_jwks(self) -> None:
        """
        Replaces the token validator with a version where the JSON Web Key Set is unaltered and working
        """
        self.deregister_token_validator(self.validator)

        token_validator = AzureTokenValidator(
            azure_tenancy_id=self.azure_tenancy_id,
            azure_application_id=self.azure_application_id,
            azure_client_application_ids=self.azure_client_application_ids,
            azure_jwks=self.jwks,
        )
        self.register_token_validator(token_validator)


test_jwks = TestJwk()


def _get_jwks():
    return test_jwks.jwks()


def create_app(**kwargs):
    app = Flask(__name__)

    app.config["AZURE_OAUTH_TENANCY"] = "test"
    app.config["AZURE_OAUTH_APPLICATION_ID"] = "test"
    app.config["AZURE_OAUTH_CLIENT_APPLICATION_IDS"] = ["test", "test2"]
    app.config["TEST_JWKS"] = test_jwks

    # Support using session
    app.config["SECRET_KEY"] = "5c7KjhU3dm4ZPz6BevZ2xw"

    # Support overriding auth provider config when testing
    if "AZURE_OAUTH_TENANCY" in kwargs:
        app.config["AZURE_OAUTH_TENANCY"] = kwargs["AZURE_OAUTH_TENANCY"]
    if "AZURE_OAUTH_APPLICATION_ID" in kwargs:
        app.config["AZURE_OAUTH_APPLICATION_ID"] = kwargs["AZURE_OAUTH_APPLICATION_ID"]
    if "AZURE_OAUTH_CLIENT_APPLICATION_IDS" in kwargs:
        app.config["AZURE_OAUTH_CLIENT_APPLICATION_IDS"] = kwargs["AZURE_OAUTH_CLIENT_APPLICATION_IDS"]

    with patch.object(FlaskAzureOauth, "_get_jwks") as mocked_get_jwks:
        mocked_get_jwks.side_effect = _get_jwks
        app.auth = TestFlaskAzureOauth()
        app.auth.init_app(app)

    # Support invalid ways of setting up the auth provider when testing
    if "AUTH_MODE" in kwargs:
        if kwargs["AUTH_MODE"] == "null-jwks":
            app.auth.use_null_jwks()
        elif kwargs["AUTH_MODE"] == "broken-jwks":
            app.auth.use_broken_jwks()
        elif kwargs["AUTH_MODE"] == "replaced-jwks":
            app.auth.use_replaced_jwks()
        elif kwargs["AUTH_MODE"] == "restored-jwks":
            app.auth.use_restored_jwks()

    @app.route("/meta/auth/introspection")
    @app.auth()
    def meta_auth_introspection():
        authorization_header = request.headers.get("authorization")
        if authorization_header is None:
            authorization_header = f"Bearer {session['access_token']}"
        token_string = authorization_header.split("Bearer ")[1]

        payload = {
            "data": {
                "token": app.auth.introspect_token(token_string=token_string),
                "token-rfc7662": app.auth.introspect_token_rfc7662(token_string=token_string),
                "token-string": token_string,
            }
        }

        return jsonify(payload)

    @app.route("/meta/auth/insufficient-scopes")
    @app.auth("unobtainable-scope")
    def meta_auth_insufficient_scopes():
        """
        Simulates a resource a client doesn't have access to due to not having the correct scopes.

        In practice it is impossible to access this resource.
        """
        return "", HTTPStatus.NO_CONTENT

    @app.route("/meta/auth/sufficient-scope")
    @app.auth("scope")
    def meta_auth_sufficient_scope():
        """
        Simulates a resource a client has access to by having the correct scope.
        """
        return "", HTTPStatus.NO_CONTENT

    @app.route("/meta/auth/sufficient-scopes")
    @app.auth("scope1 scope2")
    def meta_auth_sufficient_scopes():
        """
        Simulates a resource a client has access to by having the correct scopes.
        """
        return "", HTTPStatus.NO_CONTENT

    return app
